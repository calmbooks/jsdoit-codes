// Generated by CoffeeScript 1.4.0
(function() {
  var _this = this,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function(win, doc) {
    var Affine3Dto2D, Background, Camera, DOTS_QUANTITY, Dots, FPS, Global, LINE_QUANTITY, Line, Main, Object3D, Particle, Renderer, SKIN_QUANTITY, SPHERE_RADIUS, Utils, Vector3D, Vertex3D, ctx, cvs, cvs_l;
    Global = {};
    cvs = doc.getElementById("c");
    ctx = cvs.getContext("2d");
    cvs_l = Math.min(win.innerWidth, win.innerHeight);
    cvs.width = cvs_l;
    cvs.height = cvs_l;
    cvs.style.margin = "-" + (cvs_l / 2) + "px 0 0 -" + (cvs_l / 2) + "px";
    FPS = 60;
    SPHERE_RADIUS = 1000;
    DOTS_QUANTITY = 8;
    LINE_QUANTITY = 50;
    SKIN_QUANTITY = 4;
    Main = (function() {

      function Main() {
        _this.set_click_event = __bind(_this.set_click_event, this);

        _this.change_skin = __bind(_this.change_skin, this);

        _this.init = __bind(_this.init, this);
        this.init();
      }

      Main.prototype.init = function() {
        var camera, dots, i, line, renderer, _i, _j;
        Global.renderer = renderer = new Renderer();
        Global.camera = camera = new Camera(cvs_l, cvs_l);
        Global.skin = Math.random() * SKIN_QUANTITY | 0;
        renderer.set_camera(camera);
        this.background = new Background();
        for (i = _i = 0; 0 <= DOTS_QUANTITY ? _i < DOTS_QUANTITY : _i > DOTS_QUANTITY; i = 0 <= DOTS_QUANTITY ? ++_i : --_i) {
          dots = new Dots();
          renderer.add_object(dots);
        }
        for (i = _j = 0; 0 <= LINE_QUANTITY ? _j < LINE_QUANTITY : _j > LINE_QUANTITY; i = 0 <= LINE_QUANTITY ? ++_j : --_j) {
          line = new Line((Math.random() > 0.7 ? 1 : 0));
          renderer.add_object(line);
        }
        return this.set_click_event();
      };

      Main.prototype.change_skin = function() {
        var object, _i, _len, _ref, _results;
        Global.skin = Global.skin === (SKIN_QUANTITY - 1) ? 0 : Global.skin + 1;
        this.background.change_color();
        _ref = Global.renderer.objects;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          object = _ref[_i];
          _results.push(object.change_color());
        }
        return _results;
      };

      Main.prototype.set_click_event = function() {
        var is_touch,
          _this = this;
        is_touch = "ontouchstart" in win ? true : false;
        doc.addEventListener((is_touch ? "touchmove" : "mousemove"), function(event) {
          return event.preventDefault();
        }, false);
        return doc.addEventListener((is_touch ? "touchend" : "click"), function(event) {
          return _this.change_skin();
        }, false);
      };

      return Main;

    })();
    Background = (function() {

      Background.prototype.COLOR = ["rgb(255,130,0)", "rgb(0,200,100)", "rgb(0,120,200)", "rgb(255,100,175)"];

      function Background() {
        _this.change_color = __bind(_this.change_color, this);

        _this.set_background_color = __bind(_this.set_background_color, this);

        _this.init = __bind(_this.init, this);
        this.init();
      }

      Background.prototype.init = function() {
        return this.set_background_color();
      };

      Background.prototype.set_background_color = function() {
        this.color = this.COLOR[Global.skin];
        return doc.body.style.background = this.color;
      };

      Background.prototype.change_color = function() {
        return this.set_background_color();
      };

      return Background;

    })();
    Object3D = (function() {

      function Object3D() {
        this.vertexes = new Array();
        this.position = {
          x: 0,
          y: 0,
          z: 0
        };
        this.scale = {
          x: 1,
          y: 1,
          z: 1
        };
        this.rotate = {
          x: 0,
          y: 0,
          z: 0
        };
      }

      return Object3D;

    })();
    Particle = (function(_super) {

      __extends(Particle, _super);

      function Particle() {
        _this.change_color = __bind(_this.change_color, this);

        _this.get_archive = __bind(_this.get_archive, this);

        _this.update = __bind(_this.update, this);

        _this.get_color_rgb = __bind(_this.get_color_rgb, this);

        _this.set_position = __bind(_this.set_position, this);

        _this.value_init = __bind(_this.value_init, this);
        return Particle.__super__.constructor.apply(this, arguments);
      }

      Particle.prototype.value_init = function() {
        this.color = this.get_color_rgb();
        this.a_speed = Utils.clamp(Utils.dtr(this.ANGLE_SPEED.min), Utils.dtr(this.ANGLE_SPEED.max));
        this.h_speed = this.a_speed * 50;
        this.radius = Utils.clamp(SPHERE_RADIUS - 100, SPHERE_RADIUS + 100);
        this.position.y = Utils.clamp(this.radius * -1, this.radius);
        this.angle = Utils.clamp(0, 2 * Math.PI);
        this.h_direction = Math.random() > 0.5 ? 1 : -1;
        return this.a_direction = Math.random() > 0.5 ? 1 : -1;
      };

      Particle.prototype.set_position = function() {
        var a, r, sr, x, y, z;
        sr = this.radius;
        y = this.position.y;
        a = this.angle;
        r = Math.sqrt((sr * sr) - (y * y));
        x = r * Math.cos(a);
        z = r * Math.sin(a);
        this.position.x = x;
        return this.position.z = z;
      };

      Particle.prototype.get_color_rgb = function() {
        if (Global.skin === 0) {
          return {
            r: Utils.clamp(200, 255) | 0,
            g: Utils.clamp(0, 255) | 0,
            b: Utils.clamp(0, 255) | 0
          };
        } else if (Global.skin === 1) {
          return {
            r: Utils.clamp(0, 255) | 0,
            g: Utils.clamp(200, 255) | 0,
            b: Utils.clamp(0, 255) | 0
          };
        } else if (Global.skin === 2) {
          return {
            r: Utils.clamp(0, 255) | 0,
            g: Utils.clamp(0, 255) | 0,
            b: Utils.clamp(200, 255) | 0
          };
        } else if (Global.skin === 3) {
          return {
            r: Utils.clamp(150, 255) | 0,
            g: Utils.clamp(150, 255) | 0,
            b: Utils.clamp(150, 255) | 0
          };
        }
      };

      Particle.prototype.update = function(d) {
        var a_val, h_val, i, t, target_angle, target_y, y;
        a_val = this.a_speed * d;
        h_val = this.h_speed * d;
        target_angle = this.angle + (a_val * this.a_direction);
        target_y = this.position.y + (this.h_direction * h_val);
        i = this.angle;
        t = this.angle + a_val;
        while (i < t) {
          this.angle += this.ANGLE_DISTANCE * this.a_direction;
          y = this.position.y + (this.h_direction * this.HEIGHT_DISTANCE);
          if (Math.abs(this.angle) > t) {
            this.angle = target_angle;
            y = target_y;
          }
          if (y > this.radius) {
            y = this.radius;
            this.h_direction = -1;
            this.angle += Math.PI;
          }
          if (y < this.radius * -1) {
            y = this.radius * -1;
            this.h_direction = 1;
            this.angle += Math.PI;
          }
          this.position.y = y;
          this.rotate.y = this.angle + (Math.PI / 2);
          this.set_position();
          this.archives.unshift(this.get_archive());
          if (this.archives.length > this.AFTER_NUM) {
            this.archives = this.archives.slice(0, this.AFTER_NUM);
          }
          i += this.ANGLE_DISTANCE;
        }
        if (this.archives.length >= 2) {
          return this.render();
        }
      };

      Particle.prototype.get_archive = function() {
        var obj, prop, target, _i, _len, _ref;
        obj = {};
        _ref = ["position", "scale", "rotate"];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          prop = _ref[_i];
          target = this[prop];
          obj[prop] = {
            x: target.x,
            y: target.y,
            z: target.z
          };
        }
        obj.vertexes = this.vertexes;
        return obj;
      };

      Particle.prototype.change_color = function() {
        return this.color = this.get_color_rgb();
      };

      return Particle;

    })(Object3D);
    Line = (function(_super) {

      __extends(Line, _super);

      Line.prototype.ANGLE_SPEED = {
        min: 0.05,
        max: 0.15
      };

      Line.prototype.AFTER_NUM = 30;

      Line.prototype.ANGLE_DISTANCE = 0.2;

      Line.prototype.HEIGHT_DISTANCE = 5;

      function Line(type) {
        this.type = type;
        _this.render = __bind(_this.render, this);

        Line.__super__.constructor.apply(this, arguments);
        this.polygon = new Array();
        this.archives = new Array();
        this.vertexes = [new Vertex3D(0, 0.5, 0), new Vertex3D(0, -0.5, 0)];
        this.scale.x = 30;
        this.scale.y = Utils.clamp(30, (this.type === 0 ? 80 : 40));
        this.value_init();
        this.set_position();
      }

      Line.prototype.render = function() {
        var alpha, archive, i, max, p_0, p_1, render_object, _i, _j, _len, _ref, _ref1, _results;
        this.polygon = [];
        _ref = this.archives;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          archive = _ref[_i];
          render_object = Affine3Dto2D.get_render_object(archive, Global.camera);
          p_0 = render_object.display[0];
          p_1 = render_object.display[1];
          this.polygon.push({
            x: Math.round(p_0.x),
            y: Math.round(p_0.y)
          });
          this.polygon.push({
            x: Math.round(p_1.x),
            y: Math.round(p_1.y)
          });
        }
        _results = [];
        for (i = _j = 3, _ref1 = (max = this.polygon.length); _j < _ref1; i = _j += 2) {
          alpha = (1 - ((i / 2) / (max / 2))) / 0.35;
          if (alpha > 0.8) {
            alpha = 0.8;
          }
          ctx.fillStyle = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + alpha + ")";
          ctx.beginPath();
          ctx.moveTo(this.polygon[i].x, this.polygon[i].y);
          ctx.lineTo(this.polygon[i - 1].x, this.polygon[i - 1].y);
          if (this.type === 0) {
            ctx.lineTo(this.polygon[i - 3].x, this.polygon[i - 3].y);
            ctx.lineTo(this.polygon[i - 2].x, this.polygon[i - 2].y);
          } else if (this.type === 1) {
            ctx.lineTo(this.polygon[i - 2].x, this.polygon[i - 2].y);
            ctx.lineTo(this.polygon[i - 3].x, this.polygon[i - 3].y);
          }
          ctx.closePath();
          _results.push(ctx.fill());
        }
        return _results;
      };

      return Line;

    })(Particle);
    Dots = (function(_super) {

      __extends(Dots, _super);

      Dots.prototype.ANGLE_SPEED = {
        min: 0.2,
        max: 0.3
      };

      Dots.prototype.AFTER_NUM = 10;

      Dots.prototype.ANGLE_DISTANCE = 0.2;

      Dots.prototype.HEIGHT_DISTANCE = 5;

      function Dots() {
        _this.render = __bind(_this.render, this);
        Dots.__super__.constructor.apply(this, arguments);
        this.dots = new Array();
        this.archives = new Array();
        this.vertexes = [new Vertex3D(0, 0, 0)];
        this.value_init();
        this.set_position();
      }

      Dots.prototype.render = function() {
        var alpha, archive, dot, i, max, r, render_object, _i, _j, _len, _ref, _ref1, _results;
        this.dots = [];
        _ref = this.archives;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          archive = _ref[_i];
          render_object = Affine3Dto2D.get_render_object(archive, Global.camera);
          this.dots.push({
            x: render_object.display[0].x,
            y: render_object.display[0].y,
            d: render_object.projection[0].d
          });
        }
        _results = [];
        for (i = _j = 0, _ref1 = (max = this.dots.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          dot = this.dots[i];
          alpha = 1 - (i / max);
          ctx.fillStyle = "rgba(" + this.color.r + "," + this.color.g + "," + this.color.b + "," + alpha + ")";
          r = (1 - dot.d) * 10;
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, r, 0, 360, false);
          ctx.closePath();
          _results.push(ctx.fill());
        }
        return _results;
      };

      return Dots;

    })(Particle);
    Camera = (function() {

      Camera.prototype.SPEED = 0.01 * (Math.PI / 180);

      Camera.prototype.POSITION_RADIUS = 2100;

      Camera.prototype.zoom = 1;

      Camera.prototype.clip = {
        near: 100,
        far: 5000
      };

      Camera.prototype.target = {
        x: 0,
        y: 0,
        z: 0
      };

      function Camera(display_w, display_h) {
        this.display_w = display_w;
        this.display_h = display_h;
        _this.update = __bind(_this.update, this);

        _this.set_value = __bind(_this.set_value, this);

        _this.set_top = __bind(_this.set_top, this);

        _this.set_position = __bind(_this.set_position, this);

        _this.init = __bind(_this.init, this);

        this.aspect = this.display_w / this.display_h;
        this.display = {
          x: this.display_w * 0.5,
          y: this.display_h * 0.5
        };
        this.init();
      }

      Camera.prototype.init = function() {
        this.phi_direction = 1;
        this.set_position(this.POSITION_RADIUS, 0.1, 0.2);
        this.set_top(Math.PI / 2);
        return this.set_value();
      };

      Camera.prototype.set_position = function(r, theta, phi) {
        return this.position = {
          r: r,
          theta: theta,
          phi: phi,
          x: r * Math.sin(phi) * Math.cos(theta),
          y: r * Math.sin(phi) * Math.sin(theta),
          z: r * Math.cos(phi)
        };
      };

      Camera.prototype.set_top = function(angle) {
        return this.top = {
          angle: angle,
          x: Math.cos(angle),
          y: Math.sin(angle),
          z: 0
        };
      };

      Camera.prototype.set_value = function(d) {
        var _this = this;
        (function() {
          var l, x, y, z;
          x = _this.position.x - _this.target.x;
          y = _this.position.y - _this.target.y;
          z = _this.position.z - _this.target.z;
          l = Math.sqrt((x * x) + (y * y) + (z * z));
          return _this.view_axis_z = new Vector3D(x / l, y / l, z / l);
        })();
        (function() {
          var a1, a2, a3, b1, b2, b3, l, x, y, z;
          a1 = _this.top.x;
          a2 = _this.top.y;
          a3 = _this.top.z;
          b1 = _this.view_axis_z.x;
          b2 = _this.view_axis_z.y;
          b3 = _this.view_axis_z.z;
          x = (a2 * b3) - (a3 * b2);
          y = (a3 * b1) - (a1 * b3);
          z = (a1 * b2) - (a2 * b1);
          l = Math.sqrt((x * x) + (y * y) + (z * z));
          return _this.view_axis_x = new Vector3D(x / l, y / l, z / l);
        })();
        (function() {
          var a1, a2, a3, b1, b2, b3, l, x, y, z;
          a1 = _this.view_axis_z.x;
          a2 = _this.view_axis_z.y;
          a3 = _this.view_axis_z.z;
          b1 = _this.view_axis_x.x;
          b2 = _this.view_axis_x.y;
          b3 = _this.view_axis_x.z;
          x = (a2 * b3) - (a3 * b2);
          y = (a3 * b1) - (a1 * b3);
          z = (a1 * b2) - (a2 * b1);
          l = Math.sqrt((x * x) + (y * y) + (z * z));
          return _this.view_axis_y = new Vector3D(x / l, y / l, z / l);
        })();
        this.view_px = (this.position.x * this.view_axis_x.x) + (this.position.y * this.view_axis_x.y) + (this.position.z * this.view_axis_x.z);
        this.view_py = (this.position.x * this.view_axis_y.x) + (this.position.y * this.view_axis_y.y) + (this.position.z * this.view_axis_y.z);
        this.view_pz = (this.position.x * this.view_axis_z.x) + (this.position.y * this.view_axis_z.y) + (this.position.z * this.view_axis_z.z);
        this.projection_angle_x = Math.atan((this.display_w * 0.5) / this.clip.near);
        return this.projection_angle_y = Math.atan((this.display_h * 0.5) / this.clip.near);
      };

      Camera.prototype.update = function(d) {
        var p, r, t, top_angle;
        r = this.position.r;
        t = this.position.theta + (this.SPEED * d);
        p = this.position.phi + (this.SPEED * d * this.phi_direction);
        if (t >= (2 * Math.PI)) {
          t -= 2 * Math.PI;
        }
        if (p >= Math.PI) {
          p = Math.PI - (p - Math.PI);
          this.phi_direction *= -1;
        } else if (p <= 0) {
          p *= -1;
          this.phi_direction *= -1;
        }
        this.set_position(r, t, p);
        top_angle = this.top.angle + (this.SPEED * d);
        if (top_angle >= (2 * Math.PI)) {
          top_angle -= 2 * Math.PI;
        }
        this.set_top(top_angle);
        return this.set_value();
      };

      return Camera;

    })();
    Vertex3D = (function() {

      function Vertex3D(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }

      return Vertex3D;

    })();
    Vector3D = (function() {

      function Vector3D(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }

      return Vector3D;

    })();
    Renderer = (function() {

      Renderer.prototype.now = (win.performance && (performance.now || performance.mozNow || performance.webkitNow)) || Date.now;

      Renderer.prototype.objects = new Array();

      function Renderer() {
        _this.set_camera = __bind(_this.set_camera, this);

        _this.add_object = __bind(_this.add_object, this);

        _this.render = __bind(_this.render, this);

        _this.clear = __bind(_this.clear, this);

        _this.update = __bind(_this.update, this);

        _this.setup_update = __bind(_this.setup_update, this);

        _this.get_time = __bind(_this.get_time, this);

        _this.init = __bind(_this.init, this);
        this.init();
      }

      Renderer.prototype.init = function() {
        return this.setup_update();
      };

      Renderer.prototype.get_time = function() {
        return this.now.call(win.performance);
      };

      Renderer.prototype.setup_update = function() {
        this.timeoutID = null;
        this.last_time = this.get_time();
        return this.update();
      };

      Renderer.prototype.update = function() {
        var now_time,
          _this = this;
        if (this.timeoutID !== null) {
          return;
        }
        now_time = this.get_time();
        this.clear();
        this.render(now_time - this.last_time);
        this.timeoutID = setTimeout(function() {
          _this.timeoutID = null;
          return _this.update();
        }, 1000 / FPS);
        return this.last_time = now_time;
      };

      Renderer.prototype.clear = function() {
        return ctx.clearRect(0, 0, cvs_l, cvs_l);
      };

      Renderer.prototype.render = function(delta) {
        var object, _i, _len, _ref, _results;
        if (this.objects.length === 0 || !this.camera) {
          return;
        }
        this.camera.update(delta);
        _ref = this.objects;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          object = _ref[_i];
          _results.push(object.update(delta));
        }
        return _results;
      };

      Renderer.prototype.add_object = function(obj) {
        return this.objects.push(obj);
      };

      Renderer.prototype.set_camera = function(camera) {
        return this.camera = camera;
      };

      return Renderer;

    })();
    Utils = (function() {

      function Utils() {
        throw "Utils cant be instantiated.";
      }

      Utils.clamp = function(min, max) {
        return Math.random() * (max - min) + min;
      };

      Utils.central = function(p1, p2) {
        return (p2 - p1) * 0.5 + p1;
      };

      Utils.central2d = function(p1, p2) {
        return {
          x: (p2.x - p1.x) * 0.5 + p1.x,
          y: (p2.y - p1.y) * 0.5 + p1.y
        };
      };

      Utils.round = function(num) {
        return Math.round(num * 10) / 10;
      };

      Utils.dtr = function(d) {
        return d * (Math.PI / 180);
      };

      Utils.rtd = function(r) {
        return r * (180 / Math.PI);
      };

      return Utils;

    }).call(_this);
    Affine3Dto2D = (function() {

      function Affine3Dto2D() {
        throw "Affine3Dto2D cant be instantiated.";
      }

      Affine3Dto2D.get_render_object = function(object3d, camera) {
        var render_object;
        render_object = new Object();
        render_object.world = Affine3Dto2D.world(object3d);
        render_object.view = Affine3Dto2D.view(object3d, render_object.world, camera);
        render_object.projection = Affine3Dto2D.projection(render_object.view, camera);
        render_object.display = Affine3Dto2D.display(render_object.projection, camera);
        return render_object;
      };

      Affine3Dto2D.world = function(object3d) {
        var arr, obj, vertex, _fn, _fn1, _fn2, _fn3, _fn4, _i, _len, _ref;
        arr = new Array();
        _ref = object3d.vertexes;
        _fn = function() {
          obj.x *= object3d.scale.x;
          obj.y *= object3d.scale.y;
          return obj.z *= object3d.scale.z;
        };
        _fn1 = function() {
          var radian_x, y, z;
          radian_x = Utils.dtr(object3d.rotate.x);
          y = (obj.y * Math.cos(radian_x)) - (obj.z * Math.sin(radian_x));
          z = (obj.y * Math.sin(radian_x)) + (obj.z * Math.cos(radian_x));
          obj.y = y;
          return obj.z = z;
        };
        _fn2 = function() {
          var radian_y, x, z;
          radian_y = Utils.dtr(object3d.rotate.y);
          x = (obj.x * Math.cos(radian_y)) + (obj.z * Math.sin(radian_y));
          z = (obj.x * -1 * Math.sin(radian_y)) + (obj.z * Math.cos(radian_y));
          obj.x = x;
          return obj.z = z;
        };
        _fn3 = function() {
          var radian_z, x, y;
          radian_z = Utils.dtr(object3d.rotate.z);
          x = (obj.x * Math.cos(radian_z)) - (obj.y * Math.sin(radian_z));
          y = (obj.x * Math.sin(radian_z)) + (obj.y * Math.cos(radian_z));
          obj.x = x;
          return obj.y = y;
        };
        _fn4 = function() {
          obj.x += object3d.position.x;
          obj.y += object3d.position.y;
          return obj.z += object3d.position.z;
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          vertex = _ref[_i];
          obj = {
            x: vertex.x,
            y: vertex.y,
            z: vertex.z
          };
          _fn();
          _fn1();
          _fn2();
          _fn3();
          _fn4();
          arr.push(obj);
        }
        return arr;
      };

      Affine3Dto2D.view = function(object3d, world, camera) {
        var arr, obj, vertex, x, y, z, _i, _len;
        arr = new Array();
        for (_i = 0, _len = world.length; _i < _len; _i++) {
          vertex = world[_i];
          obj = {
            x: vertex.x,
            y: vertex.y,
            z: vertex.z
          };
          x = (obj.x * camera.view_axis_x.x) + (obj.y * camera.view_axis_x.y) + (obj.z * camera.view_axis_x.z) - camera.view_px;
          y = (obj.x * camera.view_axis_y.x) + (obj.y * camera.view_axis_y.y) + (obj.z * camera.view_axis_y.z) - camera.view_py;
          z = (obj.x * camera.view_axis_z.x) + (obj.y * camera.view_axis_z.y) + (obj.z * camera.view_axis_z.z) - camera.view_pz;
          obj.x = x;
          obj.y = y;
          obj.z = z;
          arr.push(obj);
        }
        return arr;
      };

      Affine3Dto2D.projection = function(view, camera) {
        var arr, vertex, _i, _len;
        arr = new Array();
        for (_i = 0, _len = view.length; _i < _len; _i++) {
          vertex = view[_i];
          arr.push({
            x: (vertex.x / (Math.tan(camera.projection_angle_x * 0.5) * (vertex.z * -1))) * camera.display.x * camera.zoom,
            y: (vertex.y / (Math.tan(camera.projection_angle_y * 0.5) * (vertex.z * -1))) * camera.display.y * camera.zoom,
            d: vertex.z * -1 / camera.clip.far
          });
        }
        return arr;
      };

      Affine3Dto2D.display = function(projection, camera) {
        var arr, vertex, _i, _len;
        arr = new Array();
        for (_i = 0, _len = projection.length; _i < _len; _i++) {
          vertex = projection[_i];
          arr.push({
            x: vertex.x + camera.display.x,
            y: (vertex.y * -1) + camera.display.y
          });
        }
        return arr;
      };

      return Affine3Dto2D;

    }).call(_this);
    return win.addEventListener("load", function() {
      return new Main();
    }, false);
  })(window, document);

}).call(this);
