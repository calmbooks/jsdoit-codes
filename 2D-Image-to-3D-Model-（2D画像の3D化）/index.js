// Generated by CoffeeScript 1.4.0
(function() {
  var _this = this,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function(win, doc) {
    var ASPECT, Camera, FOV_Y, FPS, Image2d, Image3d, Image3dShader, LineScene, Main, Matrix4, Object3d, Renderer, Scene, Shader, TriangleScene, Utils, canvas_l, canvas_t, cvs_h, cvs_w, gl_l, gl_t, image_wrapper;
    FPS = 30;
    FOV_Y = 90;
    canvas_t = doc.getElementById("c_triangle");
    canvas_l = doc.getElementById("c_line");
    image_wrapper = doc.getElementById("image");
    cvs_w = win.innerWidth / 2;
    cvs_h = win.innerHeight;
    canvas_t.width = cvs_w;
    canvas_t.height = cvs_h;
    canvas_l.width = cvs_w;
    canvas_l.height = cvs_h;
    ASPECT = cvs_w / cvs_h;
    gl_t = canvas_t.getContext("webgl" || canvas_t.getContext("experimental-webgl"));
    gl_l = canvas_l.getContext("webgl" || canvas_l.getContext("experimental-webgl"));
    Utils = (function() {

      function Utils() {
        throw "Utils cant be instantiated.";
      }

      Utils.get_hsv_to_rgb = function(hsv) {
        var f, h, i, p, q, rgb, s, t, v;
        h = hsv.h;
        s = hsv.s;
        v = hsv.v;
        i = Math.floor(h / 60) % 6;
        f = (h / 60) - Math.floor(h / 60);
        p = Math.round(v * (1 - (s / 255)));
        q = Math.round(v * (1 - (s / 255) * f));
        t = Math.round(v * (1 - (s / 255) * (1 - f)));
        switch (i) {
          case 0:
            rgb = {
              r: v,
              g: t,
              b: p
            };
            break;
          case 1:
            rgb = {
              r: q,
              g: v,
              b: p
            };
            break;
          case 2:
            rgb = {
              r: p,
              g: v,
              b: t
            };
            break;
          case 3:
            rgb = {
              r: p,
              g: q,
              b: v
            };
            break;
          case 4:
            rgb = {
              r: t,
              g: p,
              b: v
            };
            break;
          case 5:
            rgb = {
              r: v,
              g: p,
              b: q
            };
        }
        return rgb;
      };

      Utils.clamp = function(min, max) {
        return Math.random() * (max - min) + min;
      };

      Utils.central = function(p1, p2) {
        return (p2 - p1) * 0.5 + p1;
      };

      Utils.central2d = function(p1, p2) {
        return {
          x: (p2.x - p1.x) * 0.5 + p1.x,
          y: (p2.y - p1.y) * 0.5 + p1.y
        };
      };

      Utils.round = function(num) {
        return Math.round(num * 10) / 10;
      };

      Utils.dtr = function(d) {
        return d * (Math.PI / 180);
      };

      Utils.rtd = function(r) {
        return r * (180 / Math.PI);
      };

      return Utils;

    }).call(_this);
    Main = (function() {

      function Main() {
        _this.set_image = __bind(_this.set_image, this);

        _this.set_dragdrop_events = __bind(_this.set_dragdrop_events, this);

        _this.init = __bind(_this.init, this);
        this.init();
      }

      Main.prototype.init = function() {
        this.scene_t = new TriangleScene(gl_t);
        this.scene_l = new LineScene(gl_l);
        this.renderer_t = new Renderer(gl_t);
        this.renderer_l = new Renderer(gl_l);
        this.renderer_t.add_scene(this.scene_t);
        this.renderer_l.add_scene(this.scene_l);
        this.renderer_t.setup_update();
        this.renderer_l.setup_update();
        this.set_image("http://jsrun.it/assets/4/3/j/7/43j7k.png");
        return this.set_dragdrop_events();
      };

      Main.prototype.set_dragdrop_events = function() {
        var _this = this;
        doc.body.addEventListener("dragover", function(event) {
          return event.preventDefault();
        }, false);
        return doc.body.addEventListener("drop", function(event) {
          var files, reader;
          event.preventDefault();
          files = event.dataTransfer.files;
          reader = new FileReader();
          reader.addEventListener("load", function(event) {
            return _this.set_image(event.target.result);
          }, false);
          return reader.readAsDataURL(files[0]);
        }, false);
      };

      Main.prototype.set_image = function(image_url) {
        var image,
          _this = this;
        image = new Image();
        image.addEventListener("load", function() {
          var image2d, image3d_l, image3d_t;
          image2d = new Image2d(image);
          image3d_t = new Image3d("triangle", gl_t, image2d.get_data_3d(), [1.0, 0.2, 0.0, 1.0]);
          image3d_l = new Image3d("line", gl_l, image2d.get_data_3d(), [0.0, 0.8, 0.0, 1.0]);
          _this.scene_t.remove_all_children();
          _this.scene_l.remove_all_children();
          _this.scene_t.add_child(image3d_t);
          _this.scene_l.add_child(image3d_l);
          if (image_wrapper.childNodes.length) {
            image_wrapper.removeChild(image_wrapper.childNodes.item(0));
          }
          return image_wrapper.appendChild(image);
        }, false);
        return image.src = image_url;
      };

      return Main;

    })();
    Image2d = (function() {

      Image2d.prototype.SIZE = 200;

      Image2d.prototype.ALPHA_THRESHOLD = 200;

      Image2d.prototype.SIMPLIFY_1_THRESHOLD = 5;

      Image2d.prototype.SIMPLIFY_2_THRESHOLD = 3;

      Image2d.prototype.REMOVE_DUST_THRESHOLD = 5;

      Image2d.prototype.Z_THICKNESS = 0.1;

      function Image2d(image) {
        this.image = image;
        _this.debug_face_output = __bind(_this.debug_face_output, this);

        _this.debug_points_output = __bind(_this.debug_points_output, this);

        _this.debug_edges_normal_output = __bind(_this.debug_edges_normal_output, this);

        _this.debug_edges_output = __bind(_this.debug_edges_output, this);

        _this.debug_groups_output = __bind(_this.debug_groups_output, this);

        _this.debug_text_output = __bind(_this.debug_text_output, this);

        _this.set_data_3d = __bind(_this.set_data_3d, this);

        _this.set_edges_simplify = __bind(_this.set_edges_simplify, this);

        _this.set_edges = __bind(_this.set_edges, this);

        _this.set_group = __bind(_this.set_group, this);

        _this.set_input_simplify = __bind(_this.set_input_simplify, this);

        _this.set_input = __bind(_this.set_input, this);

        _this.get_data_3d = __bind(_this.get_data_3d, this);

        _this.init = __bind(_this.init, this);

        this.init();
      }

      Image2d.prototype.init = function() {};

      Image2d.prototype.get_data_3d = function() {
        this.input = this.set_input();
        this.simplify_input = this.set_input_simplify();
        this.groups = this.set_group();
        this.edges = this.set_edges();
        this.points = this.set_edges_simplify();
        this.data_3d = this.set_data_3d();
        this.debug_groups_output(this.groups);
        this.debug_edges_output(this.edges);
        this.debug_edges_normal_output(this.edges);
        this.debug_points_output(this.points);
        this.debug_face_output(this.data_3d, this.points);
        return this.data_3d;
      };

      Image2d.prototype.set_input = function() {
        var a, b, brightness, draw_h, draw_w, draw_x, draw_y, g, i, image_ratio, input, input_ctx, input_cvs, output, r;
        input_cvs = doc.getElementById("input");
        input_ctx = input_cvs.getContext("2d");
        input_cvs.width = this.cvs_w = this.SIZE;
        input_cvs.height = this.cvs_h = this.SIZE;
        image_ratio = this.image.width / this.image.height;
        if (this.image.width > this.image.height) {
          draw_w = this.cvs_w;
          draw_h = this.cvs_w / image_ratio;
          draw_x = 0;
          draw_y = (this.cvs_h - draw_h) / 2;
        } else {
          draw_h = this.cvs_h;
          draw_w = this.cvs_h * image_ratio;
          draw_x = (this.cvs_w - draw_w) / 2;
          draw_y = 0;
        }
        input_ctx.fillStyle = "white";
        input_ctx.fillRect(0, 0, this.cvs_w, this.cvs_h);
        input_ctx.drawImage(this.image, draw_x, draw_y, draw_w, draw_h);
        input = input_ctx.getImageData(0, 0, this.cvs_w, this.cvs_h);
        output = input_ctx.createImageData(this.cvs_w, this.cvs_h);
        i = input.data.length;
        while (0 < i) {
          i -= 4;
          r = input.data[i];
          g = input.data[i + 1];
          b = input.data[i + 2];
          a = input.data[i + 3];
          brightness = Math.max(r, g, b) * (a / 255);
          output.data[i] = 0;
          output.data[i + 1] = 0;
          output.data[i + 2] = 0;
          output.data[i + 3] = brightness < 200 ? 255 : 255 - ((brightness - 200) / 55 * 255);
        }
        input_ctx.putImageData(output, 0, 0);
        return output;
      };

      Image2d.prototype.set_input_simplify = function() {
        var alpha, b_c_s, b_w_data, h, height, i, j, m_l_s, m_r_s, m_w_data, simplify_input, t_c_s, t_w_data, temp_data, w, w_data, width, _i, _j, _k, _l, _m, _ref, _ref1, _ref2;
        temp_data = new Array();
        width = this.input.width;
        height = this.input.height;
        for (i = _i = 0, _ref = this.input.data.length; _i < _ref; i = _i += 4) {
          alpha = this.input.data[i + 3];
          temp_data.push(alpha > this.ALPHA_THRESHOLD ? alpha : 0);
        }
        simplify_input = new Array();
        for (i = _j = 0; 0 <= height ? _j < height : _j > height; i = 0 <= height ? ++_j : --_j) {
          w_data = new Array();
          h = i * width;
          for (j = _k = 0; 0 <= width ? _k < width : _k > width; j = 0 <= width ? ++_k : --_k) {
            w = h + j;
            w_data.push(temp_data[w]);
          }
          simplify_input.push(w_data);
        }
        for (h = _l = 0, _ref1 = simplify_input.length; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; h = 0 <= _ref1 ? ++_l : --_l) {
          t_w_data = simplify_input[h - 1] || [];
          m_w_data = simplify_input[h];
          b_w_data = simplify_input[h + 1] || [];
          for (w = _m = 0, _ref2 = m_w_data.length; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; w = 0 <= _ref2 ? ++_m : --_m) {
            t_c_s = t_w_data[w] || 0;
            b_c_s = b_w_data[w] || 0;
            m_l_s = m_w_data[w - 1] || 0;
            m_r_s = m_w_data[w + 1] || 0;
            if ((t_c_s === 0) && (b_c_s === 0)) {
              m_w_data[w] = 0;
            }
            if ((m_l_s === 0) && (m_r_s === 0)) {
              m_w_data[w] = 0;
            }
          }
        }
        return simplify_input;
      };

      Image2d.prototype.set_group = function() {
        var connect_group_and_group, connect_group_and_w, create_temp_group, debug_count, groups, temp_groups,
          _this = this;
        debug_count = 0;
        create_temp_group = function(h, w_data) {
          var arr, before, current, group, max, w, _i, _ref;
          arr = new Array();
          for (w = _i = 0, _ref = (max = w_data.length); 0 <= _ref ? _i < _ref : _i > _ref; w = 0 <= _ref ? ++_i : --_i) {
            before = w_data[w - 1];
            current = w_data[w];
            if ((before === void 0 || before === 0) && current > 0) {
              group = new Array();
            }
            if (current > 0) {
              group.push({
                w: w,
                h: h,
                s: current
              });
            }
            if (before > 0 && current === 0) {
              arr.push(group);
            }
            if (w === (max - 1) && current > 0) {
              arr.push(group);
            }
          }
          return arr;
        };
        connect_group_and_w = function(groups, w_temp_group) {
          var before, current, delete_group_numbers, done_group, flag_add_brother, flag_connect, flag_done, group, i, j, last_w_group, n, _i, _j, _k, _l, _len, _len1, _ref, _ref1;
          done_group = null;
          flag_done = false;
          delete_group_numbers = new Array();
          for (i = _i = 0, _ref = groups.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            group = groups[i];
            last_w_group = group[group.length - 1];
            flag_connect = false;
            flag_add_brother = false;
            if ((w_temp_group[0].h - last_w_group[0].h) > 1) {
              continue;
            }
            if (last_w_group[0].h === w_temp_group[0].h) {
              flag_add_brother = true;
              last_w_group = group[group.length - 2];
              if (last_w_group === void 0) {
                continue;
              }
            }
            for (_j = 0, _len = w_temp_group.length; _j < _len; _j++) {
              current = w_temp_group[_j];
              for (_k = 0, _len1 = last_w_group.length; _k < _len1; _k++) {
                before = last_w_group[_k];
                if (current.w === before.w) {
                  flag_connect = true;
                  break;
                }
              }
              if (flag_connect) {
                break;
              }
            }
            if (flag_connect && flag_done) {
              done_group = connect_group_and_group(done_group, group);
              delete_group_numbers.push(i);
            } else if (flag_connect) {
              if (flag_add_brother) {
                group[group.length - 1] = group[group.length - 1].concat(w_temp_group);
              } else {
                group.push(w_temp_group);
              }
              done_group = group;
              flag_done = true;
            }
          }
          for (j = _l = 0, _ref1 = delete_group_numbers.length; 0 <= _ref1 ? _l < _ref1 : _l > _ref1; j = 0 <= _ref1 ? ++_l : --_l) {
            n = delete_group_numbers[j] - j;
            groups.splice(n, 1);
          }
          return done_group;
        };
        connect_group_and_group = function(group_1, group_2) {
          var i, j, w_group_1, w_group_2, _i, _j, _ref, _ref1;
          for (i = _i = 0, _ref = group_1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            w_group_1 = group_1[i];
            for (j = _j = 0, _ref1 = group_2.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              w_group_2 = group_2[j];
              if (w_group_1[0].h === w_group_2[0].h) {
                group_1[i] = w_group_1.concat(w_group_2);
              }
            }
          }
          return group_1;
        };
        temp_groups = new Array();
        (function() {
          var h, temp_group, w_data, _i, _ref, _results;
          _results = [];
          for (h = _i = 0, _ref = _this.simplify_input.length; 0 <= _ref ? _i < _ref : _i > _ref; h = 0 <= _ref ? ++_i : --_i) {
            w_data = _this.simplify_input[h];
            temp_group = create_temp_group(h, w_data);
            _results.push(temp_groups.push(temp_group));
          }
          return _results;
        })();
        groups = new Array();
        (function() {
          var b_temp_groups, group, h, i, w_temp_group, w_temp_groups, _i, _ref, _results;
          _results = [];
          for (h = _i = 0, _ref = temp_groups.length; 0 <= _ref ? _i < _ref : _i > _ref; h = 0 <= _ref ? ++_i : --_i) {
            b_temp_groups = temp_groups[h - 1];
            w_temp_groups = temp_groups[h];
            _results.push((function() {
              var _j, _ref1, _results1;
              _results1 = [];
              for (i = _j = 0, _ref1 = w_temp_groups.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                w_temp_group = w_temp_groups[i];
                debug_count += 1;
                if (b_temp_groups === void 0 || b_temp_groups.length === 0) {
                  group = new Array();
                  group.push(w_temp_group);
                  _results1.push(groups.push(group));
                } else {
                  group = connect_group_and_w(groups, w_temp_group);
                  if (group === null) {
                    group = new Array();
                    group.push(w_temp_group);
                    _results1.push(groups.push(group));
                  } else {
                    _results1.push(void 0);
                  }
                }
              }
              return _results1;
            })());
          }
          return _results;
        })();
        return groups;
      };

      Image2d.prototype.set_edges = function() {
        var array, array_reverse, b_w_group, c_edge, check_next_edge, e_obj, edge, edge_check, edge_length, edge_w_group, first, group, h, i, m_w_group, next_edge, obj, sort_edge, sort_edge_length, sort_edges, stack_edge, stack_y, t_w_group, temp_edges, v45_x, v45_y, v_l, w_group, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2,
          _this = this;
        v_l = 10;
        v45_x = v45_y = Math.sqrt((v_l * v_l) / 2);
        edge_check = function(obj, t_w_group, m_w_group, b_w_group) {
          var angle, b_c, b_c_s, b_l, b_l_s, b_r, b_r_s, c_w, edge_bool, l_w, m_c_s, m_l, m_l_s, m_r, m_r_s, o, r_w, t_c, t_c_s, t_l, t_l_s, t_r, t_r_s, total_x, total_y, w, _i, _j, _k, _len, _len1, _len2;
          l_w = obj.w - 1;
          c_w = obj.w;
          r_w = obj.w + 1;
          m_c_s = obj.s;
          t_l_s = t_c_s = t_r_s = 0;
          b_l_s = b_c_s = b_r_s = 0;
          m_l_s = m_r_s = 0;
          for (_i = 0, _len = t_w_group.length; _i < _len; _i++) {
            o = t_w_group[_i];
            w = o.w;
            if (w === l_w) {
              t_l_s = o.s;
            }
            if (w === c_w) {
              t_c_s = o.s;
            }
            if (w === r_w) {
              t_r_s = o.s;
            }
          }
          for (_j = 0, _len1 = m_w_group.length; _j < _len1; _j++) {
            o = m_w_group[_j];
            w = o.w;
            if (w === l_w) {
              m_l_s = o.s;
            }
            if (w === r_w) {
              m_r_s = o.s;
            }
          }
          for (_k = 0, _len2 = b_w_group.length; _k < _len2; _k++) {
            o = b_w_group[_k];
            w = o.w;
            if (w === l_w) {
              b_l_s = o.s;
            }
            if (w === c_w) {
              b_c_s = o.s;
            }
            if (w === r_w) {
              b_r_s = o.s;
            }
          }
          if ((t_c_s === 0) || (m_l_s === 0) || (m_r_s === 0) || (b_c_s === 0)) {
            edge_bool = true;
          }
          if (edge_bool) {
            t_l_s = 255 - t_l_s;
            t_c_s = 255 - t_c_s;
            t_r_s = 255 - t_r_s;
            m_l_s = 255 - m_l_s;
            m_r_s = 255 - m_r_s;
            b_l_s = 255 - b_l_s;
            b_c_s = 255 - b_c_s;
            b_r_s = 255 - b_r_s;
            t_l = [-v45_x * t_l_s, v45_y * t_l_s];
            t_c = [0, v_l * t_c_s];
            t_r = [v45_x * t_r_s, v45_y * t_r_s];
            m_l = [-v_l * m_l_s, 0];
            m_r = [v_l * m_r_s, 0];
            b_l = [-v45_x * b_l_s, -v45_y * b_l_s];
            b_c = [0, -v_l * b_c_s];
            b_r = [v45_x * b_r_s, -v45_y * b_r_s];
            total_x = t_l[0] + t_c[0] + t_r[0] + m_l[0] + m_r[0] + b_l[0] + b_c[0] + b_r[0];
            total_y = t_l[1] + t_c[1] + t_r[1] + m_l[1] + m_r[1] + b_l[1] + b_c[1] + b_r[1];
            angle = Utils.rtd(Math.atan2(total_y, total_x));
            angle = angle < 0 ? angle + 360 : angle;
            angle = angle >= 360 ? angle - 360 : angle;
            obj.n = angle;
            return obj;
          } else {
            return null;
          }
        };
        temp_edges = new Array();
        _ref = this.groups;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          edge = new Array();
          for (i = _j = 0, _ref1 = group.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            t_w_group = group[i - 1] || [];
            m_w_group = group[i];
            b_w_group = group[i + 1] || [];
            edge_w_group = new Array();
            for (_k = 0, _len1 = m_w_group.length; _k < _len1; _k++) {
              obj = m_w_group[_k];
              e_obj = edge_check(obj, t_w_group, m_w_group, b_w_group);
              if (e_obj !== null) {
                e_obj.sort = 0;
                edge_w_group.push(e_obj);
              }
            }
            if (edge_w_group.length > 0) {
              edge.push(edge_w_group);
            }
          }
          temp_edges.push(edge);
        }
        sort_edges = new Array();
        check_next_edge = function(obj, c_edge, stack_edge) {
          var c, s, _ref2;
          if (obj.sort === 1) {
            return null;
          }
          if (((c_edge.w - 1) <= (_ref2 = obj.w) && _ref2 <= (c_edge.w + 1))) {
            if (stack_edge === null) {
              return obj;
            }
            c = Math.abs(c_edge.n - obj.n);
            s = Math.abs(c_edge.n - stack_edge.n);
            c = c > 180 ? 360 - c : c;
            s = s > 180 ? 360 - s : s;
            if (c < s) {
              return obj;
            }
          }
          return null;
        };
        array_reverse = function(array, direction) {
          var angle_1, angle_2, first, last, next;
          if (direction == null) {
            direction = true;
          }
          first = array[0];
          next = array[1];
          last = array[array.length - 1];
          angle_1 = Utils.rtd(Math.atan2(-(next.h - first.h), next.w - first.w));
          angle_2 = Utils.rtd(Math.atan2(-(last.h - first.h), last.w - first.w));
          angle_1 = angle_1 < 0 ? angle_1 + 360 : angle_1;
          angle_2 = angle_2 < 0 ? angle_2 + 360 : angle_2;
          if (angle_1 - angle_2 > 180) {
            angle_1 = angle_1 - 360;
          }
          if (angle_2 - angle_1 > 180) {
            angle_2 = angle_2 - 360;
          }
          if (direction && angle_1 < angle_2) {
            array.reverse();
          }
          if (!direction && angle_2 < angle_1) {
            array.reverse();
          }
          return array;
        };
        for (_l = 0, _len2 = temp_edges.length; _l < _len2; _l++) {
          edge = temp_edges[_l];
          sort_edge = new Array();
          y = 0;
          first = edge[y][0];
          first.sort = 1;
          array = new Array();
          array.push(first);
          edge_length = 0;
          for (_m = 0, _len3 = edge.length; _m < _len3; _m++) {
            w_group = edge[_m];
            edge_length += w_group.length;
          }
          sort_edge_length = 1;
          while (sort_edge_length < edge_length) {
            c_edge = array[array.length - 1];
            t_w_group = edge[y - 1] || [];
            m_w_group = edge[y];
            b_w_group = edge[y + 1] || [];
            stack_edge = null;
            stack_y = null;
            for (_n = 0, _len4 = t_w_group.length; _n < _len4; _n++) {
              obj = t_w_group[_n];
              next_edge = check_next_edge(obj, c_edge, stack_edge);
              if (next_edge !== null) {
                stack_edge = next_edge;
                stack_y = y - 1;
              }
            }
            for (_o = 0, _len5 = m_w_group.length; _o < _len5; _o++) {
              obj = m_w_group[_o];
              next_edge = check_next_edge(obj, c_edge, stack_edge);
              if (next_edge !== null) {
                stack_edge = next_edge;
                stack_y = y;
              }
            }
            for (_p = 0, _len6 = b_w_group.length; _p < _len6; _p++) {
              obj = b_w_group[_p];
              next_edge = check_next_edge(obj, c_edge, stack_edge);
              if (next_edge !== null) {
                stack_edge = next_edge;
                stack_y = y + 1;
              }
            }
            if (stack_edge === null) {
              for (h = _q = 0, _ref2 = edge.length; 0 <= _ref2 ? _q < _ref2 : _q > _ref2; h = 0 <= _ref2 ? ++_q : --_q) {
                w_group = edge[h];
                for (_r = 0, _len7 = w_group.length; _r < _len7; _r++) {
                  obj = w_group[_r];
                  if (obj.sort === 0) {
                    array = array_reverse(array, (sort_edge.length > 0 ? false : true));
                    if (array.length > this.REMOVE_DUST_THRESHOLD) {
                      sort_edge.push(array);
                    }
                    array = new Array();
                    stack_edge = obj;
                    stack_y = h;
                    break;
                  }
                }
                if (stack_edge !== null) {
                  break;
                }
              }
            }
            stack_edge.sort = 1;
            array.push(stack_edge);
            y = stack_y;
            sort_edge_length += 1;
          }
          array = array_reverse(array, (sort_edge.length > 0 ? false : true));
          if (array.length > this.REMOVE_DUST_THRESHOLD) {
            sort_edge.push(array);
          }
          sort_edges.push(sort_edge);
        }
        return sort_edges;
      };

      Image2d.prototype.set_edges_simplify = function() {
        var array, c, c_edge, c_point, current, edge, edge_group, edge_group_length, f_angle, i, lag, max_lag, min_lag, n_point, point, point_group, point_group_length, points, stack_point, t_angle, t_edge, t_point, temp_point, temp_points, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _n, _ref, _ref1, _ref2;
        temp_points = new Array();
        _ref = this.edges;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          edge = _ref[_i];
          temp_point = new Array();
          for (_j = 0, _len1 = edge.length; _j < _len1; _j++) {
            edge_group = edge[_j];
            array = new Array();
            c = 0;
            current = edge_group[c];
            array.push(current);
            edge_group_length = edge_group.length;
            while ((c + 1) < edge_group_length) {
              c_edge = array[array.length - 1];
              for (i = _k = _ref1 = c + 1; _ref1 <= edge_group_length ? _k < edge_group_length : _k > edge_group_length; i = _ref1 <= edge_group_length ? ++_k : --_k) {
                t_edge = edge_group[i];
                lag = Math.abs(t_edge.n - c_edge.n);
                lag = lag > 180 ? 360 - lag : lag;
                if (lag > this.SIMPLIFY_1_THRESHOLD) {
                  array.push(t_edge);
                  current = t_edge;
                  c = i;
                  break;
                } else if (i === (edge_group_length - 1)) {
                  c = i;
                }
              }
            }
            temp_point.push(array);
          }
          temp_points.push(temp_point);
        }
        points = new Array();
        for (_l = 0, _len2 = temp_points.length; _l < _len2; _l++) {
          temp_point = temp_points[_l];
          point = new Array();
          for (_m = 0, _len3 = temp_point.length; _m < _len3; _m++) {
            point_group = temp_point[_m];
            array = new Array();
            c = 0;
            current = point_group[c];
            array.push(current);
            point_group_length = point_group.length;
            while ((c + 1) < point_group_length) {
              c_point = array[array.length - 1];
              n_point = point_group[c + 1];
              f_angle = Utils.rtd(Math.atan2(n_point.h - c_point.h, n_point.w - c_point.w));
              f_angle = f_angle < 0 ? f_angle + 360 : f_angle;
              f_angle = f_angle >= 360 ? f_angle - 360 : f_angle;
              min_lag = null;
              max_lag = null;
              stack_point = n_point;
              for (i = _n = _ref2 = c + 2; _ref2 <= point_group_length ? _n <= point_group_length : _n >= point_group_length; i = _ref2 <= point_group_length ? ++_n : --_n) {
                if (i === point_group_length) {
                  t_point = point_group[0];
                } else {
                  t_point = point_group[i];
                }
                t_angle = Utils.rtd(Math.atan2(t_point.h - c_point.h, t_point.w - c_point.w));
                t_angle = t_angle < 0 ? t_angle + 360 : t_angle;
                t_angle = t_angle >= 360 ? t_angle - 360 : t_angle;
                min_lag = min_lag === null ? t_angle - f_angle : Math.min(min_lag, t_angle - f_angle);
                max_lag = max_lag === null ? t_angle - f_angle : Math.max(max_lag, t_angle - f_angle);
                if ((max_lag - min_lag) > this.SIMPLIFY_2_THRESHOLD) {
                  array.push(stack_point);
                  current = stack_point;
                  c = i - 1;
                  break;
                } else if (i === point_group_length) {
                  c = i;
                  break;
                } else {
                  stack_point = t_point;
                }
              }
            }
            point.push(array);
          }
          points.push(point);
        }
        return points;
      };

      Image2d.prototype.set_data_3d = function() {
        var before_point_length, bool, c, c_point, check_connect, check_cross, connect_hole, current_t, face, false_count, false_max, fill_points, flag_decide_t, hole_connect_points, i, j, max, n, n_point, next_n, normal, obj, origin, p_0, p_1, p_2, p_3, point, point_count, point_group, point_loop, points_length, reverse_face, side_face, t, t_point, temp_face, tri_length, vertex, z_l, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _s,
          _this = this;
        z_l = this.Z_THICKNESS / 2;
        origin = this.SIZE / 2;
        check_cross = function(d_x, d_y, a, b, point, outside_point, other, next) {
          var check1_bool_1, check1_bool_2, o_a, o_b, o_d_x, o_d_y, x, y;
          o_d_x = next.w - other.w;
          o_d_y = next.h - other.h;
          o_a = o_d_y / o_d_x;
          o_b = other.h - o_a * other.w;
          if (d_x === 0 && o_d_x === 0) {
            return false;
          }
          if (d_y === 0 && o_d_y === 0) {
            return false;
          }
          if (d_x === 0) {
            x = point.w;
            y = o_a * x + o_b;
          } else if (o_d_x === 0) {
            x = other.w;
            y = a * x + b;
          } else if (d_y === 0) {
            y = point.h;
            x = (y - o_b) / o_a;
          } else if (o_d_y === 0) {
            y = other.h;
            x = (y - b) / a;
          } else {
            x = (o_b - b) / (a - o_a);
            y = a * x + b;
          }
          if (x === outside_point.w && y === outside_point.h) {
            return true;
          }
          if (x === point.w && y === point.h) {
            return true;
          }
          if (x === other.w && y === other.h) {
            return true;
          }
          if (x === next.w && y === next.h) {
            return true;
          }
          if (d_x === 0) {
            check1_bool_1 = (outside_point.h < y && y < point.h) || (point.h < y && y < outside_point.h) ? true : false;
          } else {
            check1_bool_1 = (outside_point.w < x && x < point.w) || (point.w < x && x < outside_point.w) ? true : false;
          }
          if (o_d_x === 0) {
            check1_bool_2 = (other.h < y && y < next.h) || (next.h < y && y < other.h) ? true : false;
          } else {
            check1_bool_2 = (other.w < x && x < next.w) || (next.w < x && x < other.w) ? true : false;
          }
          if (check1_bool_1 && check1_bool_2) {
            return true;
          } else {
            return false;
          }
        };
        connect_hole = function(outside_points, point_loop) {
          var a, b, check1_bool, check2_bool, d_x, d_y, deside_outside_point_n, deside_point_n, hole_connect_points, i, j, k, l, next, other, outside_point, point, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
          for (i = _i = 0, _ref = point_loop.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            point = point_loop[i];
            deside_outside_point_n = null;
            deside_point_n = null;
            for (j = _j = 0, _ref1 = outside_points.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              outside_point = outside_points[j];
              d_x = outside_point.w - point.w;
              d_y = outside_point.h - point.h;
              a = d_y / d_x;
              b = point.h - a * point.w;
              for (k = _k = 0, _ref2 = outside_points.length - 1; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
                other = outside_points[k];
                next = outside_points[k + 1];
                if (other === outside_point || next === outside_point) {
                  continue;
                }
                check1_bool = check_cross(d_x, d_y, a, b, point, outside_point, other, next);
                if (check1_bool) {
                  break;
                } else {
                  continue;
                }
              }
              for (l = _l = 0, _ref3 = point_loop.length - 1; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; l = 0 <= _ref3 ? ++_l : --_l) {
                other = point_loop[l];
                next = point_loop[l + 1];
                if (other === point || next === point) {
                  continue;
                }
                check2_bool = check_cross(d_x, d_y, a, b, point, outside_point, other, next);
                if (check2_bool) {
                  break;
                } else {
                  continue;
                }
              }
              if (!check1_bool && !check2_bool) {
                deside_outside_point_n = j;
                break;
              }
            }
            if (deside_outside_point_n !== null) {
              deside_point_n = i;
              break;
            }
          }
          hole_connect_points = new Array();
          (function() {
            var key, temp_obj;
            hole_connect_points = hole_connect_points.concat(outside_points.slice(0, deside_outside_point_n));
            temp_obj = {};
            for (key in (outside_point = outside_points[deside_outside_point_n])) {
              temp_obj[key] = outside_point[key];
            }
            hole_connect_points.push(temp_obj);
            hole_connect_points = hole_connect_points.concat(point_loop.slice(deside_point_n));
            hole_connect_points = hole_connect_points.concat(point_loop.slice(0, deside_point_n));
            temp_obj = {};
            for (key in (point = point_loop[deside_point_n])) {
              temp_obj[key] = point[key];
            }
            hole_connect_points.push(temp_obj);
            return hole_connect_points = hole_connect_points.concat(outside_points.slice(deside_outside_point_n));
          })();
          return hole_connect_points;
        };
        for (i = _i = 0, _ref = this.points.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          fill_points = this.points[i];
          if (fill_points.length <= 1) {
            continue;
          }
          hole_connect_points = new Array();
          for (j = _j = 0, _ref1 = fill_points.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            point_loop = fill_points[j];
            if (hole_connect_points.length === 0) {
              hole_connect_points = hole_connect_points.concat(point_loop);
            } else {
              hole_connect_points = connect_hole(hole_connect_points, point_loop);
            }
          }
          this.points[i] = [hole_connect_points];
        }
        vertex = new Array();
        normal = new Array();
        _ref2 = this.points;
        for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
          point = _ref2[_k];
          point_group = point[0];
          for (_l = 0, _len1 = point_group.length; _l < _len1; _l++) {
            obj = point_group[_l];
            vertex = vertex.concat([(obj.w - origin) / this.SIZE, (obj.h - origin) / this.SIZE, z_l]);
            normal = normal.concat([0, 0, 1]);
            obj.tri = 0;
          }
        }
        _ref3 = this.points;
        for (_m = 0, _len2 = _ref3.length; _m < _len2; _m++) {
          point = _ref3[_m];
          point_group = point[0];
          for (_n = 0, _len3 = point_group.length; _n < _len3; _n++) {
            obj = point_group[_n];
            vertex = vertex.concat([(obj.w - origin) / this.SIZE, (obj.h - origin) / this.SIZE, z_l * -1]);
            normal = normal.concat([0, 0, -1]);
            obj.tri = 0;
          }
        }
        check_connect = function(c_point, n_point, t_point, point_group, n) {
          var a_1, a_2, angle_1, angle_2, b_1, b_2, d_x_1, d_x_2, d_y_1, d_y_2, line1_bool, line2_bool, x, y, _len4, _o, _ref4, _ref5, _ref6, _ref7;
          for (_o = 0, _len4 = point_group.length; _o < _len4; _o++) {
            point = point_group[_o];
            if (c_point === point || n_point === point || t_point === point) {
              continue;
            }
            d_x_1 = point.w - c_point.w;
            d_y_1 = point.h - c_point.h;
            d_x_2 = t_point.w - n_point.w;
            d_y_2 = t_point.h - n_point.h;
            if (d_x_1 === 0 && d_x_2 === 0) {
              continue;
            }
            if (d_y_1 === 0 && d_y_2 === 0) {
              continue;
            }
            a_1 = d_y_1 / d_x_1;
            b_1 = c_point.h - a_1 * c_point.w;
            a_2 = d_y_2 / d_x_2;
            b_2 = n_point.h - a_2 * n_point.w;
            if (d_x_1 === 0) {
              x = c_point.w;
              y = a_2 * x + b_2;
            } else if (d_x_2 === 0) {
              x = n_point.w;
              y = a_1 * x + b_1;
            } else if (d_y_1 === 0) {
              y = c_point.h;
              x = (y - b_2) / a_2;
            } else if (d_y_2 === 0) {
              y = n_point.h;
              x = (y - b_1) / a_1;
            } else {
              x = (b_2 - b_1) / (a_1 - a_2);
              y = a_1 * x + b_1;
            }
            if (d_x_1 === 0) {
              line1_bool = (y < (_ref4 = point.h) && _ref4 < c_point.h) || (c_point.h < (_ref5 = point.h) && _ref5 < y) ? true : false;
            } else {
              line1_bool = (x < (_ref6 = point.w) && _ref6 < c_point.w) || (c_point.w < (_ref7 = point.w) && _ref7 < x) ? true : false;
            }
            if (d_x_2 === 0) {
              line2_bool = (n_point.h < y && y < t_point.h) || (t_point.h < y && y < n_point.h) ? true : false;
            } else {
              line2_bool = (n_point.w < x && x < t_point.w) || (t_point.w < x && x < n_point.w) ? true : false;
            }
            if (line1_bool && line2_bool) {
              return false;
              break;
            }
          }
          angle_1 = Utils.rtd(Math.atan2(-(n_point.h - c_point.h), n_point.w - c_point.w));
          angle_2 = Utils.rtd(Math.atan2(-(t_point.h - c_point.h), t_point.w - c_point.w));
          angle_1 = angle_1 < 0 ? angle_1 + 360 : angle_1;
          angle_2 = angle_2 < 0 ? angle_2 + 360 : angle_2;
          if (angle_1 - angle_2 > 180) {
            angle_1 = angle_1 - 360;
          }
          if (angle_2 - angle_1 > 180) {
            angle_2 = angle_2 - 360;
          }
          if (angle_1 <= angle_2) {
            return false;
          }
          return true;
        };
        face = new Array();
        before_point_length = 0;
        _ref4 = this.points;
        for (_o = 0, _len4 = _ref4.length; _o < _len4; _o++) {
          point = _ref4[_o];
          point_group = point[0];
          temp_face = new Array();
          c = 0;
          n = c + 1;
          t = n + 1;
          tri_length = point_group.length - 2;
          c_point = point_group[c];
          n_point = point_group[n];
          t_point = point_group[t];
          false_count = 0;
          false_max = point_group.length * 10;
          while (temp_face.length < (tri_length * 3)) {
            bool = check_connect(c_point, n_point, t_point, point_group, n);
            if (bool) {
              n_point.tri = 1;
              temp_face = temp_face.concat([before_point_length + c, before_point_length + t, before_point_length + n]);
            } else {
              c = n;
              c_point = point_group[c];
              false_count += 1;
            }
            n = t;
            n_point = point_group[n];
            flag_decide_t = false;
            current_t = t;
            while (!flag_decide_t) {
              t += 1;
              if (t >= point_group.length) {
                t = 0;
              }
              t_point = point_group[t];
              if (t_point.tri === 0) {
                flag_decide_t = true;
              }
              if (t === current_t) {
                break;
              }
            }
            if (!flag_decide_t) {
              break;
            }
            if (false_count > false_max) {
              break;
            }
          }
          face = face.concat(temp_face);
          before_point_length += point_group.length;
        }
        reverse_face = new Array();
        points_length = 0;
        _ref5 = this.points;
        for (_p = 0, _len5 = _ref5.length; _p < _len5; _p++) {
          point = _ref5[_p];
          points_length += point[0].length;
        }
        for (_q = 0, _len6 = face.length; _q < _len6; _q++) {
          i = face[_q];
          reverse_face.push(i + points_length);
        }
        face = face.concat(reverse_face);
        side_face = new Array();
        point_count = 0;
        _ref6 = this.points;
        for (_r = 0, _len7 = _ref6.length; _r < _len7; _r++) {
          point = _ref6[_r];
          point_group = point[0];
          for (i = _s = point_count, _ref7 = (max = point_count + point_group.length); point_count <= _ref7 ? _s < _ref7 : _s > _ref7; i = point_count <= _ref7 ? ++_s : --_s) {
            next_n = (i + 1) === max ? point_count : i + 1;
            p_0 = i;
            p_1 = next_n;
            p_2 = i + points_length;
            p_3 = next_n + points_length;
            side_face = side_face.concat([p_0, p_1, p_2, p_1, p_3, p_2]);
          }
          point_count += point_group.length;
        }
        face = face.concat(side_face);
        return {
          vertex: vertex,
          face: face,
          normal: normal
        };
      };

      Image2d.prototype.debug_text_output = function() {
        var arr, array, n, str, w_data, _i, _j, _len, _len1, _ref;
        array = new Array();
        _ref = this.simplify_input;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          w_data = _ref[_i];
          arr = new Array();
          for (_j = 0, _len1 = w_data.length; _j < _len1; _j++) {
            n = w_data[_j];
            str = String(n);
            if (str.length === 1) {
              str = "00" + str;
            }
            if (str.length === 2) {
              str = "0" + str;
            }
            arr.push(str);
          }
          array.push(arr);
        }
        return doc.getElementById("area").innerHTML = JSON.stringify(array);
      };

      Image2d.prototype.debug_groups_output = function(groups) {
        var color_hsv, group, n, obj, output, output_ctx, output_cvs, rgb, w_group, _i, _j, _k, _len, _len1, _len2;
        output_cvs = doc.getElementById("group");
        output_ctx = output_cvs.getContext("2d");
        output_cvs.width = this.cvs_w;
        output_cvs.height = this.cvs_h;
        color_hsv = {
          h: 0,
          s: 255,
          v: 255
        };
        output = output_ctx.createImageData(this.cvs_w, this.cvs_h);
        for (_i = 0, _len = groups.length; _i < _len; _i++) {
          group = groups[_i];
          rgb = Utils.get_hsv_to_rgb(color_hsv);
          for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
            w_group = group[_j];
            for (_k = 0, _len2 = w_group.length; _k < _len2; _k++) {
              obj = w_group[_k];
              n = (this.cvs_w * obj.h + obj.w) * 4;
              output.data[n] = rgb.r;
              output.data[n + 1] = rgb.g;
              output.data[n + 2] = rgb.b;
              output.data[n + 3] = obj.s;
            }
          }
          color_hsv.h += 40;
          if (color_hsv.h > 360) {
            color_hsv.h = 0;
          }
        }
        return output_ctx.putImageData(output, 0, 0);
      };

      Image2d.prototype.debug_edges_output = function(edges) {
        var edge, n, obj, output, output_ctx, output_cvs, w_group, _i, _j, _k, _len, _len1, _len2;
        output_cvs = doc.getElementById("edge");
        output_ctx = output_cvs.getContext("2d");
        output_cvs.width = this.cvs_w;
        output_cvs.height = this.cvs_h;
        output = output_ctx.createImageData(this.cvs_w, this.cvs_h);
        for (_i = 0, _len = edges.length; _i < _len; _i++) {
          edge = edges[_i];
          for (_j = 0, _len1 = edge.length; _j < _len1; _j++) {
            w_group = edge[_j];
            for (_k = 0, _len2 = w_group.length; _k < _len2; _k++) {
              obj = w_group[_k];
              n = (this.cvs_w * obj.h + obj.w) * 4;
              output.data[n] = 255;
              output.data[n + 1] = 0;
              output.data[n + 2] = 0;
              output.data[n + 3] = 255;
            }
          }
        }
        return output_ctx.putImageData(output, 0, 0);
      };

      Image2d.prototype.debug_edges_normal_output = function(edges) {
        var edge, l, obj, output_ctx, output_cvs, target_x, target_y, w_group, _i, _len, _results;
        output_cvs = doc.getElementById("normal");
        output_ctx = output_cvs.getContext("2d");
        output_cvs.width = this.cvs_w;
        output_cvs.height = this.cvs_h;
        l = 15;
        _results = [];
        for (_i = 0, _len = edges.length; _i < _len; _i++) {
          edge = edges[_i];
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = edge.length; _j < _len1; _j++) {
              w_group = edge[_j];
              _results1.push((function() {
                var _k, _len2, _results2;
                _results2 = [];
                for (_k = 0, _len2 = w_group.length; _k < _len2; _k++) {
                  obj = w_group[_k];
                  target_x = obj.w + Math.cos(Utils.dtr(obj.n)) * l;
                  target_y = obj.h - Math.sin(Utils.dtr(obj.n)) * l;
                  output_ctx.strokeStyle = "rgba(255,0,0,0.3)";
                  output_ctx.beginPath();
                  output_ctx.moveTo(obj.w, obj.h);
                  output_ctx.lineTo(target_x, target_y);
                  _results2.push(output_ctx.stroke());
                }
                return _results2;
              })());
            }
            return _results1;
          })());
        }
        return _results;
      };

      Image2d.prototype.debug_points_output = function(points) {
        var i, obj, output_ctx, output_cvs, point, point_group, _i, _len, _results;
        output_cvs = doc.getElementById("point");
        output_ctx = output_cvs.getContext("2d");
        output_cvs.width = this.cvs_w;
        output_cvs.height = this.cvs_h;
        _results = [];
        for (_i = 0, _len = points.length; _i < _len; _i++) {
          point_group = points[_i];
          _results.push((function() {
            var _j, _k, _len1, _ref, _results1;
            _results1 = [];
            for (_j = 0, _len1 = point_group.length; _j < _len1; _j++) {
              point = point_group[_j];
              output_ctx.fillStyle = "red";
              output_ctx.strokeStyle = "#0F0";
              output_ctx.beginPath();
              for (i = _k = 0, _ref = point.length; 0 <= _ref ? _k < _ref : _k > _ref; i = 0 <= _ref ? ++_k : --_k) {
                obj = point[i];
                if (i === 0) {
                  output_ctx.moveTo(obj.w, obj.h);
                } else {
                  output_ctx.lineTo(obj.w, obj.h);
                }
              }
              output_ctx.closePath();
              output_ctx.stroke();
              _results1.push((function() {
                var _l, _len2, _results2;
                _results2 = [];
                for (_l = 0, _len2 = point.length; _l < _len2; _l++) {
                  obj = point[_l];
                  output_ctx.beginPath();
                  output_ctx.arc(obj.w, obj.h, 2.5, 0, 2 * Math.PI, false);
                  _results2.push(output_ctx.fill());
                }
                return _results2;
              })());
            }
            return _results1;
          })());
        }
        return _results;
      };

      Image2d.prototype.debug_face_output = function(data_3d, points) {
        var face, i, i_1, i_1_x, i_1_y, i_2, i_2_x, i_2_y, i_3, i_3_x, i_3_y, index, obj, origin, output_ctx, output_cvs, point, point_group, vertex, _i, _j, _len, _ref, _results;
        output_cvs = doc.getElementById("face");
        output_ctx = output_cvs.getContext("2d");
        output_cvs.width = this.cvs_w;
        output_cvs.height = this.cvs_h;
        vertex = data_3d.vertex;
        face = data_3d.face;
        origin = this.SIZE / 2;
        output_ctx.strokeStyle = "rgba(0,0,255,0.5)";
        for (i = _i = 0, _ref = face.length; _i < _ref; i = _i += 3) {
          index = face[i];
          i_1 = face[i];
          i_2 = face[i + 1];
          i_3 = face[i + 2];
          i_1_x = vertex[i_1 * 3] * this.SIZE + origin;
          i_1_y = vertex[i_1 * 3 + 1] * this.SIZE + origin;
          i_2_x = vertex[i_2 * 3] * this.SIZE + origin;
          i_2_y = vertex[i_2 * 3 + 1] * this.SIZE + origin;
          i_3_x = vertex[i_3 * 3] * this.SIZE + origin;
          i_3_y = vertex[i_3 * 3 + 1] * this.SIZE + origin;
          output_ctx.beginPath();
          output_ctx.moveTo(i_1_x, i_1_y);
          output_ctx.lineTo(i_2_x, i_2_y);
          output_ctx.lineTo(i_3_x, i_3_y);
          output_ctx.closePath();
          output_ctx.stroke();
        }
        _results = [];
        for (_j = 0, _len = points.length; _j < _len; _j++) {
          point_group = points[_j];
          _results.push((function() {
            var _k, _len1, _results1;
            _results1 = [];
            for (_k = 0, _len1 = point_group.length; _k < _len1; _k++) {
              point = point_group[_k];
              _results1.push((function() {
                var _l, _len2, _results2;
                _results2 = [];
                for (_l = 0, _len2 = point.length; _l < _len2; _l++) {
                  obj = point[_l];
                  output_ctx.fillStyle = obj.tri === 1 ? "red" : "yellow";
                  output_ctx.beginPath();
                  output_ctx.arc(obj.w, obj.h, 2.5, 0, 2 * Math.PI, false);
                  _results2.push(output_ctx.fill());
                }
                return _results2;
              })());
            }
            return _results1;
          })());
        }
        return _results;
      };

      return Image2d;

    })();
    Renderer = (function() {

      Renderer.prototype.now = (win.performance && (performance.now || performance.mozNow || performance.webkitNow)) || Date.now;

      function Renderer(gl) {
        this.gl = gl;
        _this.update_vp_matrix = __bind(_this.update_vp_matrix, this);

        _this.update = __bind(_this.update, this);

        _this.setup_update = __bind(_this.setup_update, this);

        _this.get_time = __bind(_this.get_time, this);

        _this.add_scene = __bind(_this.add_scene, this);

        _this.init = __bind(_this.init, this);

        this.init();
      }

      Renderer.prototype.init = function() {
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.depthFunc(this.gl.LEQUAL);
        return this.camera = new Camera();
      };

      Renderer.prototype.add_scene = function(scene) {
        return this.scene = scene;
      };

      Renderer.prototype.get_time = function() {
        return this.now.call(win.performance);
      };

      Renderer.prototype.setup_update = function() {
        this.timeout_id = null;
        this.last_time = this.get_time();
        return this.update();
      };

      Renderer.prototype.update = function() {
        var delta, now_time,
          _this = this;
        if (this.timeout_id !== null) {
          return;
        }
        now_time = this.get_time();
        delta = now_time - this.last_time;
        this.update_vp_matrix();
        this.scene.update(this.vp_matrix, delta, this.camera);
        this.timeout_id = setTimeout(function() {
          _this.timeout_id = null;
          return _this.update();
        }, 1000 / FPS);
        return this.last_time = now_time;
      };

      Renderer.prototype.update_vp_matrix = function() {
        var projection_matrix, view_matrix;
        view_matrix = Matrix4.get_view(this.camera.position, this.camera.target, this.camera.top);
        projection_matrix = Matrix4.get_projection(FOV_Y, ASPECT, this.camera.near, this.camera.far);
        return this.vp_matrix = Matrix4.get_multiply(view_matrix, projection_matrix);
      };

      return Renderer;

    })();
    Camera = (function() {

      Camera.prototype.zoom = 1;

      Camera.prototype.near = 0.1;

      Camera.prototype.far = 1000;

      Camera.prototype.position = [0, 0, 0.5];

      Camera.prototype.target = [0, 0, 0];

      Camera.prototype.top = [0, 1, 0];

      function Camera() {
        _this.init = __bind(_this.init, this);
        this.init();
      }

      Camera.prototype.init = function() {};

      return Camera;

    })();
    Scene = (function() {

      function Scene() {
        _this.update = __bind(_this.update, this);

        _this.remove_all_children = __bind(_this.remove_all_children, this);

        _this.remove_child = __bind(_this.remove_child, this);

        _this.add_child = __bind(_this.add_child, this);

        _this.init = __bind(_this.init, this);

      }

      Scene.prototype.init = function() {
        return this.children = new Array();
      };

      Scene.prototype.add_child = function(child) {
        return this.children.push(child);
      };

      Scene.prototype.remove_child = function(child) {
        var i, _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.children.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (this.children[i] === child) {
            _results.push(this.children.splice(i, 1));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      Scene.prototype.remove_all_children = function() {
        return this.children = [];
      };

      Scene.prototype.update = function(vp_matrix, delta, camera) {
        var child, _i, _len, _ref;
        this.gl.clearColor(0, 0, 0, 0);
        this.gl.clearDepth(1);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.light_position = [0, 2, 3];
        _ref = this.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          if (child.visible && !child.visible) {
            continue;
          }
          child.update(vp_matrix, this.light_position, delta, this.AMBIENT_COLOR, camera);
        }
        return this.gl.flush();
      };

      return Scene;

    })();
    LineScene = (function(_super) {

      __extends(LineScene, _super);

      LineScene.prototype.AMBIENT_COLOR = [1, 1, 1, 1];

      function LineScene(gl) {
        this.gl = gl;
        this.init();
      }

      return LineScene;

    })(Scene);
    TriangleScene = (function(_super) {

      __extends(TriangleScene, _super);

      TriangleScene.prototype.AMBIENT_COLOR = [0.6, 0.6, 0.6, 1.0];

      function TriangleScene(gl) {
        this.gl = gl;
        this.init();
      }

      return TriangleScene;

    })(Scene);
    Object3d = (function() {

      function Object3d() {
        _this.line_render = __bind(_this.line_render, this);

        _this.point_render = __bind(_this.point_render, this);

        _this.triangle_render = __bind(_this.triangle_render, this);

        _this.update = __bind(_this.update, this);

        _this.create_ibo = __bind(_this.create_ibo, this);

        _this.create_vbo = __bind(_this.create_vbo, this);

        _this.init = __bind(_this.init, this);

      }

      Object3d.prototype.init = function() {
        this.ibo = this.create_ibo(this.vertex_index);
        this.position_vbo = this.create_vbo(this.vertex_position);
        this.normal_vbo = this.create_vbo(this.vertex_normal);
        this.render = this["" + this.type + "_render"];
        return this.text_rotation = 0;
      };

      Object3d.prototype.create_vbo = function(data) {
        var vbo;
        vbo = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(data), this.gl.STATIC_DRAW);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
        return vbo;
      };

      Object3d.prototype.create_ibo = function(data) {
        var ibo;
        ibo = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, ibo);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), this.gl.STATIC_DRAW);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
        return ibo;
      };

      Object3d.prototype.update = function(vp_matrix, light_position, delta, ambient_color, camera) {
        this.text_rotation += delta * 0.03;
        this.scale_matrix = Matrix4.get_scale(this.scale);
        this.rotate_x_matrix = Matrix4.get_rotate_x((Math.PI / 180) * this.text_rotation);
        this.rotate_y_matrix = Matrix4.get_rotate_y((Math.PI / 180) * this.text_rotation);
        this.translate_matrix = Matrix4.get_translate(this.position);
        this.model_matrix = Matrix4.get_multiply(this.scale_matrix, this.rotate_x_matrix);
        this.model_matrix = Matrix4.get_multiply(this.model_matrix, this.rotate_y_matrix);
        this.model_matrix = Matrix4.get_multiply(this.model_matrix, this.translate_matrix);
        this.mvp_matrix = Matrix4.get_multiply(this.model_matrix, vp_matrix);
        this.inverse_matrix = Matrix4.get_inverse(this.model_matrix);
        this.shader.update(this.position_vbo, this.normal_vbo, this.color, light_position, ambient_color, camera, this.mvp_matrix, this.inverse_matrix);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.ibo);
        return this.render();
      };

      Object3d.prototype.triangle_render = function() {
        return this.gl.drawElements(this.gl.TRIANGLES, this.vertex_index.length, this.gl.UNSIGNED_SHORT, 0);
      };

      Object3d.prototype.point_render = function() {
        return this.gl.drawElements(this.gl.POINTS, this.vertex_index.length, this.gl.UNSIGNED_SHORT, 0);
      };

      Object3d.prototype.line_render = function() {
        return this.gl.drawElements(this.gl.LINE_STRIP, this.vertex_index.length, this.gl.UNSIGNED_SHORT, 0);
      };

      return Object3d;

    })();
    Image3d = (function(_super) {

      __extends(Image3d, _super);

      function Image3d(type, gl, data_3d, color) {
        this.type = type;
        this.gl = gl;
        this.color = color;
        _this.set_prop = __bind(_this.set_prop, this);

        this.set_prop(data_3d);
        this.init();
      }

      Image3d.prototype.set_prop = function(data_3d) {
        this.vertex_position = data_3d.vertex;
        this.vertex_normal = data_3d.normal;
        this.vertex_index = data_3d.face;
        this.position = [0.0, 0.0, 0.0];
        this.scale = [1, -1, 1];
        return this.shader = new Image3dShader(this.gl);
      };

      return Image3d;

    })(Object3d);
    Shader = (function() {

      function Shader() {
        _this.reset_attribute = __bind(_this.reset_attribute, this);

        _this.set_attribute = __bind(_this.set_attribute, this);

        _this.create_program = __bind(_this.create_program, this);

        _this.create_shader = __bind(_this.create_shader, this);

      }

      Shader.prototype.create_shader = function(id) {
        var element, shader;
        element = doc.getElementById(id);
        if (element.type === "x-shader/x-vertex") {
          shader = this.gl.createShader(this.gl.VERTEX_SHADER);
        } else if (element.type === "x-shader/x-fragment") {
          shader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        } else {
          return;
        }
        this.gl.shaderSource(shader, element.text);
        this.gl.compileShader(shader);
        return shader;
      };

      Shader.prototype.create_program = function(vs, fs) {
        var program;
        program = this.gl.createProgram();
        this.gl.attachShader(program, vs);
        this.gl.attachShader(program, fs);
        this.gl.linkProgram(program);
        this.gl.useProgram(program);
        return program;
      };

      Shader.prototype.set_attribute = function(vbo, location, stride) {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
        this.gl.enableVertexAttribArray(location);
        return this.gl.vertexAttribPointer(location, stride, this.gl.FLOAT, false, 0, 0);
      };

      Shader.prototype.reset_attribute = function(location) {
        return this.gl.disableVertexAttribArray(location);
      };

      return Shader;

    })();
    Image3dShader = (function(_super) {

      __extends(Image3dShader, _super);

      function Image3dShader(gl) {
        this.gl = gl;
        _this.update = __bind(_this.update, this);

        _this.init = __bind(_this.init, this);

        this.init();
      }

      Image3dShader.prototype.init = function() {
        var f_shader, v_shader;
        v_shader = this.create_shader("Image3dShader_vertex");
        f_shader = this.create_shader("Image3dShader_fragment");
        this.program = this.create_program(v_shader, f_shader);
        this.attribute_location = {
          position: this.gl.getAttribLocation(this.program, "position"),
          normal: this.gl.getAttribLocation(this.program, "normal")
        };
        return this.uniform_location = {
          mvp_matrix: this.gl.getUniformLocation(this.program, "mvp_matrix"),
          inverse_matrix: this.gl.getUniformLocation(this.program, "inverse_matrix"),
          light_position: this.gl.getUniformLocation(this.program, "light_position"),
          eye_direction: this.gl.getUniformLocation(this.program, "eye_direction"),
          ambient_color: this.gl.getUniformLocation(this.program, "ambient_color"),
          light_power: this.gl.getUniformLocation(this.program, "light_power"),
          color: this.gl.getUniformLocation(this.program, "color")
        };
      };

      Image3dShader.prototype.update = function(position_vbo, normal_vbo, color, light_position, ambient_color, camera, mvp_matrix, inverse_matrix) {
        this.gl.useProgram(this.program);
        this.set_attribute(position_vbo, this.attribute_location.position, 3);
        this.set_attribute(normal_vbo, this.attribute_location.normal, 3);
        this.gl.uniformMatrix4fv(this.uniform_location.mvp_matrix, false, mvp_matrix);
        this.gl.uniformMatrix4fv(this.uniform_location.inverse_matrix, false, inverse_matrix);
        this.gl.uniform4fv(this.uniform_location.color, color);
        this.gl.uniform3fv(this.uniform_location.light_position, light_position);
        this.gl.uniform3fv(this.uniform_location.eye_direction, camera.position);
        this.gl.uniform4fv(this.uniform_location.ambient_color, ambient_color);
        return this.gl.uniform1f(this.uniform_location.light_power, 1);
      };

      return Image3dShader;

    })(Shader);
    Matrix4 = (function() {

      function Matrix4() {
        throw "Matrix4 cant be instantiated.";
      }

      Matrix4.create = function() {
        return Matrix4.identity();
      };

      Matrix4.identity = function() {
        var dest;
        dest = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        return dest;
      };

      Matrix4.get_multiply = function(mat_a, mat_b) {
        var a11, a12, a13, a14, a21, a22, a23, a24, a31, a32, a33, a34, a41, a42, a43, a44, b11, b12, b13, b14, b21, b22, b23, b24, b31, b32, b33, b34, b41, b42, b43, b44, dest;
        a11 = mat_a[0];
        a12 = mat_a[1];
        a13 = mat_a[2];
        a14 = mat_a[3];
        a21 = mat_a[4];
        a22 = mat_a[5];
        a23 = mat_a[6];
        a24 = mat_a[7];
        a31 = mat_a[8];
        a32 = mat_a[9];
        a33 = mat_a[10];
        a34 = mat_a[11];
        a41 = mat_a[12];
        a42 = mat_a[13];
        a43 = mat_a[14];
        a44 = mat_a[15];
        b11 = mat_b[0];
        b12 = mat_b[1];
        b13 = mat_b[2];
        b14 = mat_b[3];
        b21 = mat_b[4];
        b22 = mat_b[5];
        b23 = mat_b[6];
        b24 = mat_b[7];
        b31 = mat_b[8];
        b32 = mat_b[9];
        b33 = mat_b[10];
        b34 = mat_b[11];
        b41 = mat_b[12];
        b42 = mat_b[13];
        b43 = mat_b[14];
        b44 = mat_b[15];
        dest = [a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44];
        return dest;
      };

      Matrix4.get_scale = function(vec) {
        var dest, x, y, z;
        x = vec[0];
        y = vec[1];
        z = vec[2];
        dest = [x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1];
        return dest;
      };

      Matrix4.get_rotate_x = function(angle) {
        var c, dest, s;
        s = Math.sin(angle);
        c = Math.cos(angle);
        dest = [1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1];
        return dest;
      };

      Matrix4.get_rotate_y = function(angle) {
        var c, dest, s;
        s = Math.sin(angle);
        c = Math.cos(angle);
        dest = [c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1];
        return dest;
      };

      Matrix4.get_rotate_z = function(angle) {
        var c, dest, s;
        s = Math.sin(angle);
        c = Math.cos(angle);
        dest = [c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        return dest;
      };

      Matrix4.get_translate = function(vec) {
        var dest, x, y, z;
        x = vec[0];
        y = vec[1];
        z = vec[2];
        dest = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1];
        return dest;
      };

      Matrix4.get_view = function(position, target, top) {
        var dest, l1, l2, l3, px, py, pz, x1, x2, x3, xx, xy, xz, y1, y2, y3, yx, yy, yz, z1, z2, z3, zx, zy, zz;
        x1 = position[0] - target[0];
        y1 = position[1] - target[1];
        z1 = position[2] - target[2];
        l1 = Math.sqrt((x1 * x1) + (y1 * y1) + (z1 * z1));
        zx = x1 / l1;
        zy = y1 / l1;
        zz = z1 / l1;
        x2 = (top[1] * zz) - (top[2] * zy);
        y2 = (top[2] * zx) - (top[0] * zz);
        z2 = (top[0] * zy) - (top[1] * zx);
        l2 = Math.sqrt((x2 * x2) + (y2 * y2) + (z2 * z2));
        xx = x2 / l2;
        xy = y2 / l2;
        xz = z2 / l2;
        x3 = (zy * xz) - (zz * xy);
        y3 = (zz * xx) - (zx * xz);
        z3 = (zx * xy) - (zy * xx);
        l3 = Math.sqrt((x3 * x3) + (y3 * y3) + (z3 * z3));
        yx = x3 / l3;
        yy = y3 / l3;
        yz = z3 / l3;
        px = (position[0] * xx) + (position[1] * xy) + (position[2] * xz);
        py = (position[0] * yx) + (position[1] * yy) + (position[2] * yz);
        pz = (position[0] * zx) + (position[1] * zy) + (position[2] * zz);
        dest = [xx, xy, xz, 0, yx, yy, yz, 0, zx, zy, zz, 0, -px, -py, -pz, 1];
        return dest;
      };

      Matrix4.get_projection = function(fov_y, aspect, near, far) {
        var dest, m11, m22, m33, m34, rad;
        rad = (Math.PI / 180) * fov_y;
        m22 = 1 / Math.tan(rad / 2);
        m11 = m22 / aspect;
        m33 = -far / (far - near);
        m34 = -(far * near) / (far - near);
        dest = [m11, 0, 0, 0, 0, m22, 0, 0, 0, 0, m33, -1, 0, 0, m34, 0];
        return dest;
      };

      Matrix4.get_inverse = function(mat) {
        var a11, a12, a13, a14, a21, a22, a23, a24, a31, a32, a33, a34, a41, a42, a43, a44, b11, b12, b13, b14, b21, b22, b23, b24, b31, b32, b33, b34, b41, b42, b43, b44, dest, det, n1, n10, n11, n12, n2, n3, n4, n5, n6, n7, n8, n9;
        a11 = mat[0];
        a12 = mat[1];
        a13 = mat[2];
        a14 = mat[3];
        a21 = mat[4];
        a22 = mat[5];
        a23 = mat[6];
        a24 = mat[7];
        a31 = mat[8];
        a32 = mat[9];
        a33 = mat[10];
        a34 = mat[11];
        a41 = mat[12];
        a42 = mat[13];
        a43 = mat[14];
        a44 = mat[15];
        n1 = a11 * a22 - a12 * a21;
        n2 = a11 * a23 - a13 * a21;
        n3 = a11 * a24 - a14 * a21;
        n4 = a12 * a23 - a13 * a22;
        n5 = a12 * a24 - a14 * a22;
        n6 = a13 * a24 - a14 * a23;
        n7 = a31 * a42 - a32 * a41;
        n8 = a31 * a43 - a33 * a41;
        n9 = a31 * a44 - a34 * a41;
        n10 = a32 * a43 - a33 * a42;
        n11 = a32 * a44 - a34 * a42;
        n12 = a33 * a44 - a34 * a43;
        b11 = a22 * n12 - a23 * n11 + a24 * n10;
        b12 = a12 * -n12 + a13 * n11 - a14 * n10;
        b13 = a42 * n6 - a43 * n5 + a44 * n4;
        b14 = a32 * -n6 + a33 * n5 - a34 * n4;
        b21 = a21 * -n12 + a23 * n9 - a24 * n8;
        b22 = a11 * n12 - a13 * n9 + a14 * n8;
        b23 = a41 * -n6 + a43 * n3 - a44 * n2;
        b24 = a31 * n6 - a33 * n3 + a34 * n2;
        b31 = a21 * n11 - a22 * n9 + a24 * n7;
        b32 = a11 * -n11 + a12 * n9 - a14 * n7;
        b33 = a41 * n5 - a42 * n3 + a44 * n1;
        b34 = a31 * -n5 + a32 * n3 - a34 * n1;
        b41 = a21 * -n10 + a22 * n8 - a23 * n7;
        b42 = a11 * n10 - a12 * n8 + a13 * n7;
        b43 = a41 * -n4 + a42 * n2 - a43 * n1;
        b44 = a31 * n4 - a32 * n2 + a33 * n1;
        det = a11 * b11 + a21 * b12 + a31 * b13 + a41 * b14;
        dest = [b11 / det, b12 / det, b13 / det, b14 / det, b21 / det, b22 / det, b23 / det, b24 / det, b31 / det, b32 / det, b33 / det, b34 / det, b41 / det, b42 / det, b43 / det, b44 / det];
        return dest;
      };

      return Matrix4;

    }).call(_this);
    return win.addEventListener("load", function() {
      return new Main();
    }, false);
  })(window, document);

}).call(this);
