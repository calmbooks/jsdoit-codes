// Generated by CoffeeScript 1.4.0
(function() {
  var _this = this,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  (function(win, doc) {
    var FPS, INCREASE, Main, Point, ROTATE, SPEED, ctx, cvs, cvs_H, cvs_H_half, cvs_W, cvs_W_half;
    cvs = doc.getElementById("c");
    ctx = cvs.getContext("2d");
    cvs.width = cvs_W = win.innerWidth;
    cvs.height = cvs_H = win.innerHeight;
    cvs_W_half = cvs_W * 0.5;
    cvs_H_half = cvs_H * 0.5;
    FPS = 60;
    SPEED = 0.005;
    ROTATE = 0.06;
    INCREASE = 0.01;
    Main = (function() {

      function Main() {
        _this.draw = __bind(_this.draw, this);

        _this.get_hsv_to_rgb = __bind(_this.get_hsv_to_rgb, this);

        _this.get_point_quadratic = __bind(_this.get_point_quadratic, this);

        _this.reset = __bind(_this.reset, this);

        _this.setup_draw = __bind(_this.setup_draw, this);

        _this.update = __bind(_this.update, this);

        _this.setup_update = __bind(_this.setup_update, this);

        _this.set_points = __bind(_this.set_points, this);

        _this.init = __bind(_this.init, this);
        this.init();
      }

      Main.prototype.init = function() {
        this.distance = Math.min(cvs_W, cvs_H) * 0.5 - 10;
        this.radius = this.distance * 0.2;
        this.distance_max = this.distance * 1.5;
        this.ratio = 0;
        this.side = 0;
        this.direction = 0;
        this.color_hsv = {
          h: 0,
          s: 150,
          v: 255
        };
        this.last = new Point(0, 0);
        this.center = new Point(cvs_W * 0.5, cvs_H * 0.5);
        ctx.translate(this.center.x, this.center.y);
        this.set_points(this.side, this.direction);
        return this.setup_update();
      };

      Main.prototype.set_points = function(side, direction) {
        var d;
        d = this.distance * -1;
        this.start = side === 0 ? new Point(0, 0) : new Point(0, d);
        this.control = side === direction ? new Point(this.radius * -1, d) : new Point(this.radius, this.distance * -1);
        return this.target = side === 0 ? new Point(0, d) : new Point(0, 0);
      };

      Main.prototype.setup_update = function() {
        this.timeoutID = null;
        this.last_time = Date.now();
        return this.update();
      };

      Main.prototype.update = function() {
        var delta, now_time,
          _this = this;
        if (this.timeoutID !== null) {
          return;
        }
        now_time = Date.now();
        delta = now_time - this.last_time;
        this.setup_draw(delta);
        this.timeoutID = setTimeout(function() {
          _this.timeoutID = null;
          return _this.update();
        }, 1000 / FPS);
        return this.last_time = now_time;
      };

      Main.prototype.setup_draw = function(d) {
        var next, next_ratio, rgb, width;
        next_ratio = this.ratio + (d * SPEED);
        if (next_ratio > 1) {
          next_ratio = 1;
        }
        while (this.ratio < next_ratio) {
          this.ratio += INCREASE;
          next = this.get_point_quadratic(this.ratio);
          this.color_hsv.h += INCREASE;
          if (this.color_hsv.h > 360) {
            this.color_hsv.h = 0;
          }
          rgb = this.get_hsv_to_rgb(this.color_hsv);
          width = this.side === 0 ? this.ratio * 10 : (1 - this.ratio) * 10;
          this.draw(this.last, next, "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")", width);
          this.last = next;
        }
        if (this.ratio >= 1) {
          return this.reset();
        }
      };

      Main.prototype.reset = function() {
        if (this.side === 0) {
          this.side = 1;
        } else {
          ctx.rotate(Math.PI + ROTATE);
          this.direction = this.direction === 0 ? 1 : 0;
          this.side = 0;
          this.distance -= 1;
          this.radius = this.distance * 0.2;
          if (Math.abs(this.distance) > this.distance_max) {
            this.distance = this.distance_max;
          }
        }
        this.set_points(this.side, this.direction);
        return this.ratio = 0;
      };

      Main.prototype.get_point_quadratic = function(t) {
        var tp, x, y;
        tp = 1 - t;
        x = (t * t * this.target.x) + (2 * t * tp * this.control.x) + (tp * tp * this.start.x);
        y = (t * t * this.target.y) + (2 * t * tp * this.control.y) + (tp * tp * this.start.y);
        return new Point(x, y);
      };

      Main.prototype.get_hsv_to_rgb = function(hsv) {
        var f, h, i, p, q, rgb, s, t, v;
        h = hsv.h;
        s = hsv.s;
        v = hsv.v;
        i = Math.floor(h / 60) % 6;
        f = (h / 60) - Math.floor(h / 60);
        p = Math.round(v * (1 - (s / 255)));
        q = Math.round(v * (1 - (s / 255) * f));
        t = Math.round(v * (1 - (s / 255) * (1 - f)));
        switch (i) {
          case 0:
            rgb = {
              r: v,
              g: t,
              b: p
            };
            break;
          case 1:
            rgb = {
              r: q,
              g: v,
              b: p
            };
            break;
          case 2:
            rgb = {
              r: p,
              g: v,
              b: t
            };
            break;
          case 3:
            rgb = {
              r: p,
              g: q,
              b: v
            };
            break;
          case 4:
            rgb = {
              r: t,
              g: p,
              b: v
            };
            break;
          case 5:
            rgb = {
              r: v,
              g: p,
              b: q
            };
        }
        return rgb;
      };

      Main.prototype.draw = function(last, next, color, width) {
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(next.x, next.y);
        return ctx.stroke();
      };

      return Main;

    })();
    Point = (function() {

      function Point(x, y) {
        this.x = x;
        this.y = y;
      }

      return Point;

    })();
    return win.addEventListener("load", function() {
      return new Main();
    }, false);
  })(window, document);

}).call(this);
